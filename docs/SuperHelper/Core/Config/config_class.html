<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>SuperHelper.Core.Config.config_class API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>SuperHelper.Core.Config.config_class</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This module contains the Config class, which contains the application configuration.
from __future__ import annotations

import copy
import logging
from functools import wraps
from typing import Callable

from SuperHelper.Core.Utils import TypeCheck

logger: logging.Logger = logging.getLogger(&#34;SuperHelper.Core.Config&#34;)

DefaultCoreConfig: dict[str, ...] = {
    &#34;INSTALLED_MODULES&#34;: [
    ],
}

__all__ = [
    &#34;DefaultCoreConfig&#34;,
    &#34;Config&#34;,
    &#34;make_config_global&#34;,
    &#34;pass_config&#34;,
]


class Singleton(type):
    &#34;&#34;&#34;An internal metaclass, only used for `Config`.&#34;&#34;&#34;
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            logger.debug(&#34;Initialising config&#34;)
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]


class Config(metaclass=Singleton):
    &#34;&#34;&#34;The configuration of the application.&#34;&#34;&#34;
    _core_lock: bool = False

    def __init__(self, core: dict[str, ...] = None, modules: dict[str, dict[str, ...]] = None) -&gt; None:
        self._Core: dict[str, ...] = core if core is not None else DefaultCoreConfig
        self._Modules: dict[str, ...] = modules if modules is not None else dict()
        return

    def get_core_config(self, lock: bool = True) -&gt; dict[str, ...]:
        &#34;&#34;&#34;Gets the configuration of Core CLI.

        This function is intended for internal use only, used for the decorator `pass_config`.

        Args:
            lock (bool): Whether to lock the config or not.

        Returns:
            A dictionary mapping keys to corresponding values of the core config. Each entry is represented by a
            key-value pair of the dictionary. For example:

            ```
            {&#34;DEBUG&#34;: ..., &#34;INSTALLED_MODULES&#34;: [...]}
            ```

            The keys are always strings, and the values can be of any JSON-serializable type.

        Raises:
            RuntimeError: The core config is locked by another call.
        &#34;&#34;&#34;
        TypeCheck.ensure_bool(lock, &#34;lock&#34;)
        if Config._core_lock:
            raise RuntimeError(&#34;Core config is locked, read access is not allowed!&#34;)
        if lock:
            # Lock core config
            Config._core_lock = True
        return copy.deepcopy(self._Core)

    def set_core_config(self, config: dict[str, ...]) -&gt; None:
        &#34;&#34;&#34;Sets the configuration of Core CLI.

        This function is intended for internal use only, used for the decorator `pass_config`.

        Args:
            config (dict[str, ...]): A dictionary with string keys of the core configuration.

        Returns:
            None

        Raises:
            RuntimeError: The last retrieval of the core config was not locked, hence it is read-only.
        &#34;&#34;&#34;
        # Release lock core config
        if not Config._core_lock:
            raise RuntimeError(&#34;Core config is unlocked, write access is not allowed!&#34;)
        Config._core_lock = False
        self._Core = copy.deepcopy(config)
        return

    def apply_core_patch(self, config: dict[str, ...]) -&gt; None:
        &#34;&#34;&#34;Applies a new patch to core configuration.

        This function should only be used by Core CLI.

        Args:
            config (dict[str, ...]): The patch of the configuration.

        Returns:
            None

        Raises:
            RuntimeError: An error has occurred in `self.get_core_config()`
        &#34;&#34;&#34;
        # Secure core config
        core_config = self.get_core_config()
        # Apply patch
        config = copy.deepcopy(config)
        config.update(core_config)
        # Release core config
        self.set_core_config(core_config)

    def get_module_config(self, module_name: str, lock: bool = True) -&gt; dict[str, ...]:
        &#34;&#34;&#34;Gets the configuration of the specified module.

        This function is intended for internal use only, used for the decorator `pass_config`.

        Args:
            module_name (str): The name of the module that the config belongs to.
            lock (bool): Whether to lock the config or not.

        Returns:
            A dictionary mapping keys to corresponding values of the module config. Each entry is represented by a
            key-value pair of the dictionary. For example:

            ```
            {&#34;DEBUG&#34;: ..., &#34;INSTALLED_MODULES&#34;: [...]}
            ```

            The keys are always strings, and the values can be of any JSON-serializable type.

        Raises:
            RuntimeError: The module config is locked by another call.
        &#34;&#34;&#34;
        lock_name = f&#34;{module_name}_lock&#34;
        if getattr(self, lock_name, False):
            raise RuntimeError(f&#34;&#39;{module_name}&#39; config is locked, read access is not allowed!&#34;)
        if lock:
            # Lock module config
            setattr(self, lock_name, True)
        if module_name not in self._Modules.keys():
            # Make placeholder
            self._Modules[module_name] = dict()
        return copy.deepcopy(self._Modules[module_name])

    def set_module_config(self, module_name: str, config: dict[str, ...]) -&gt; None:
        &#34;&#34;&#34;Sets the module configuration.

        This function is intended for internal use only, used for the decorator `pass_config`.

        Args:
            module_name (str): The name of the module that the config belongs to.
            config (dict[str, ...]): A dictionary with string keys of the core configuration.

        Returns:
            None

        Raises:
            RuntimeError: The last retrieval of the module config was not locked, hence it is read-only.
        &#34;&#34;&#34;
        # Release lock module config
        lock_name = f&#34;{module_name}_lock&#34;
        is_locked = not getattr(self, lock_name, False)
        is_set = module_name in config.keys()
        if is_locked and not is_set:
            raise RuntimeError(f&#34;&#39;{module_name}&#39; config is unlocked, write access is not allowed!&#34;)
        setattr(self, lock_name, False)
        self._Modules[module_name] = copy.deepcopy(config)
        return

    def apply_module_patch(self, module_name: str, config: dict[str, ...]) -&gt; None:
        &#34;&#34;&#34;Applies a new patch to the module configuration.

        Args:
            module_name (str): The name of the module to apply patch to.
            config (dict[str, ...]): The patch of the configuration.

        Returns:
            None
        &#34;&#34;&#34;
        # Secure module config
        module_config = self.get_module_config(module_name)
        # Apply patch
        config = copy.deepcopy(config)
        config.update(module_config)
        # Release module config
        self.set_module_config(module_name, config)

    def __dict__(self) -&gt; dict[str, dict[str, ...]]:
        return {
            &#34;Core&#34;: self._Core,
            &#34;Modules&#34;: self._Modules,
        }

    @staticmethod
    def from_dict(config: dict[str]) -&gt; Config:
        if &#34;Core&#34; in config.keys() and &#34;Modules&#34; in config.keys():
            return Config(core=config[&#34;Core&#34;], modules=config[&#34;Modules&#34;])


# The container for the global configuration of the application
global_config: Config


def make_config_global(cfg: Config) -&gt; None:
    &#34;&#34;&#34;Makes the configuration global.

    Args:
        cfg (Config): The `Config` instance.

    Returns:
        None
    &#34;&#34;&#34;
    global global_config
    global_config = cfg


def pass_config(core: bool = None, module_name: str = None, lock: bool = False, param_name: str = &#34;config&#34;) -&gt; Callable:
    &#34;&#34;&#34;Passes the requested config to decorated functions.

    The wrapped function will receive the config (as requested). When the function returns (or raises SystemExit), this
    decorator will capture that signal, save the config (if locked) before returning (or re-raising SystemExit).

    Args:
        core (bool): Whether to request core config.
        module_name (str): The name of the module.
        lock (bool): Whether to lock the config, i.e allow writing to the config.
        param_name (str): The name of the parameter that the config will be passed as.

    Returns:
        A Callable instance (the decorated function).

    Raises:
        SystemExit: Re-raises the `SystemExit()` raised by the wrapped function.
        ValueError: Both `core` and `module_name` are specified.
    &#34;&#34;&#34;

    def decorator(f: Callable) -&gt; Callable:
        @wraps(f)
        def wrapper(*args, **kwargs) -&gt; ...:
            if core is None and module_name is None:
                return f(global_config, *args, **kwargs)
            elif core is not None and module_name is None:
                if lock:
                    config = global_config.get_core_config(lock=True)
                    kwargs[param_name] = config
                    try:
                        ret_val = f(*args, **kwargs)
                        global_config.set_core_config(config)
                        return ret_val
                    except SystemExit:
                        global_config.set_core_config(config)
                        raise
                else:
                    kwargs[param_name] = global_config.get_core_config(lock=False)
                    return f(*args, **kwargs)
            elif core is None and module_name is not None:
                if lock:
                    config = global_config.get_module_config(module_name, lock=True)
                    kwargs[param_name] = config
                    try:
                        ret_val = f(*args, **kwargs)
                        global_config.set_module_config(module_name, config)
                        return ret_val
                    except SystemExit:
                        global_config.set_module_config(module_name, config)
                        raise
                else:
                    kwargs[param_name] = global_config.get_module_config(module_name, lock=lock)
                    return f(*args, **kwargs)
            else:
                raise ValueError(&#34;Core and module name cannot be enabled at the same time!&#34;)

        return wrapper

    return decorator</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="SuperHelper.Core.Config.config_class.make_config_global"><code class="name flex">
<span>def <span class="ident">make_config_global</span></span>(<span>cfg: <a title="SuperHelper.Core.Config.config_class.Config" href="#SuperHelper.Core.Config.config_class.Config">Config</a>) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Makes the configuration global.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code><a title="SuperHelper.Core.Config.config_class.Config" href="#SuperHelper.Core.Config.config_class.Config">Config</a></code></dt>
<dd>The <code><a title="SuperHelper.Core.Config.config_class.Config" href="#SuperHelper.Core.Config.config_class.Config">Config</a></code> instance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_config_global(cfg: Config) -&gt; None:
    &#34;&#34;&#34;Makes the configuration global.

    Args:
        cfg (Config): The `Config` instance.

    Returns:
        None
    &#34;&#34;&#34;
    global global_config
    global_config = cfg</code></pre>
</details>
</dd>
<dt id="SuperHelper.Core.Config.config_class.pass_config"><code class="name flex">
<span>def <span class="ident">pass_config</span></span>(<span>core: bool = None, module_name: str = None, lock: bool = False, param_name: str = 'config') ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Passes the requested config to decorated functions.</p>
<p>The wrapped function will receive the config (as requested). When the function returns (or raises SystemExit), this
decorator will capture that signal, save the config (if locked) before returning (or re-raising SystemExit).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>core</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to request core config.</dd>
<dt><strong><code>module_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the module.</dd>
<dt><strong><code>lock</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to lock the config, i.e allow writing to the config.</dd>
<dt><strong><code>param_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the parameter that the config will be passed as.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Callable instance (the decorated function).</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>SystemExit</code></dt>
<dd>Re-raises the <code>SystemExit()</code> raised by the wrapped function.</dd>
<dt><code>ValueError</code></dt>
<dd>Both <code>core</code> and <code>module_name</code> are specified.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pass_config(core: bool = None, module_name: str = None, lock: bool = False, param_name: str = &#34;config&#34;) -&gt; Callable:
    &#34;&#34;&#34;Passes the requested config to decorated functions.

    The wrapped function will receive the config (as requested). When the function returns (or raises SystemExit), this
    decorator will capture that signal, save the config (if locked) before returning (or re-raising SystemExit).

    Args:
        core (bool): Whether to request core config.
        module_name (str): The name of the module.
        lock (bool): Whether to lock the config, i.e allow writing to the config.
        param_name (str): The name of the parameter that the config will be passed as.

    Returns:
        A Callable instance (the decorated function).

    Raises:
        SystemExit: Re-raises the `SystemExit()` raised by the wrapped function.
        ValueError: Both `core` and `module_name` are specified.
    &#34;&#34;&#34;

    def decorator(f: Callable) -&gt; Callable:
        @wraps(f)
        def wrapper(*args, **kwargs) -&gt; ...:
            if core is None and module_name is None:
                return f(global_config, *args, **kwargs)
            elif core is not None and module_name is None:
                if lock:
                    config = global_config.get_core_config(lock=True)
                    kwargs[param_name] = config
                    try:
                        ret_val = f(*args, **kwargs)
                        global_config.set_core_config(config)
                        return ret_val
                    except SystemExit:
                        global_config.set_core_config(config)
                        raise
                else:
                    kwargs[param_name] = global_config.get_core_config(lock=False)
                    return f(*args, **kwargs)
            elif core is None and module_name is not None:
                if lock:
                    config = global_config.get_module_config(module_name, lock=True)
                    kwargs[param_name] = config
                    try:
                        ret_val = f(*args, **kwargs)
                        global_config.set_module_config(module_name, config)
                        return ret_val
                    except SystemExit:
                        global_config.set_module_config(module_name, config)
                        raise
                else:
                    kwargs[param_name] = global_config.get_module_config(module_name, lock=lock)
                    return f(*args, **kwargs)
            else:
                raise ValueError(&#34;Core and module name cannot be enabled at the same time!&#34;)

        return wrapper

    return decorator</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="SuperHelper.Core.Config.config_class.Config"><code class="flex name class">
<span>class <span class="ident">Config</span></span>
<span>(</span><span>core: dict[str, ...] = None, modules: dict[str, dict[str, ...]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The configuration of the application.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Config(metaclass=Singleton):
    &#34;&#34;&#34;The configuration of the application.&#34;&#34;&#34;
    _core_lock: bool = False

    def __init__(self, core: dict[str, ...] = None, modules: dict[str, dict[str, ...]] = None) -&gt; None:
        self._Core: dict[str, ...] = core if core is not None else DefaultCoreConfig
        self._Modules: dict[str, ...] = modules if modules is not None else dict()
        return

    def get_core_config(self, lock: bool = True) -&gt; dict[str, ...]:
        &#34;&#34;&#34;Gets the configuration of Core CLI.

        This function is intended for internal use only, used for the decorator `pass_config`.

        Args:
            lock (bool): Whether to lock the config or not.

        Returns:
            A dictionary mapping keys to corresponding values of the core config. Each entry is represented by a
            key-value pair of the dictionary. For example:

            ```
            {&#34;DEBUG&#34;: ..., &#34;INSTALLED_MODULES&#34;: [...]}
            ```

            The keys are always strings, and the values can be of any JSON-serializable type.

        Raises:
            RuntimeError: The core config is locked by another call.
        &#34;&#34;&#34;
        TypeCheck.ensure_bool(lock, &#34;lock&#34;)
        if Config._core_lock:
            raise RuntimeError(&#34;Core config is locked, read access is not allowed!&#34;)
        if lock:
            # Lock core config
            Config._core_lock = True
        return copy.deepcopy(self._Core)

    def set_core_config(self, config: dict[str, ...]) -&gt; None:
        &#34;&#34;&#34;Sets the configuration of Core CLI.

        This function is intended for internal use only, used for the decorator `pass_config`.

        Args:
            config (dict[str, ...]): A dictionary with string keys of the core configuration.

        Returns:
            None

        Raises:
            RuntimeError: The last retrieval of the core config was not locked, hence it is read-only.
        &#34;&#34;&#34;
        # Release lock core config
        if not Config._core_lock:
            raise RuntimeError(&#34;Core config is unlocked, write access is not allowed!&#34;)
        Config._core_lock = False
        self._Core = copy.deepcopy(config)
        return

    def apply_core_patch(self, config: dict[str, ...]) -&gt; None:
        &#34;&#34;&#34;Applies a new patch to core configuration.

        This function should only be used by Core CLI.

        Args:
            config (dict[str, ...]): The patch of the configuration.

        Returns:
            None

        Raises:
            RuntimeError: An error has occurred in `self.get_core_config()`
        &#34;&#34;&#34;
        # Secure core config
        core_config = self.get_core_config()
        # Apply patch
        config = copy.deepcopy(config)
        config.update(core_config)
        # Release core config
        self.set_core_config(core_config)

    def get_module_config(self, module_name: str, lock: bool = True) -&gt; dict[str, ...]:
        &#34;&#34;&#34;Gets the configuration of the specified module.

        This function is intended for internal use only, used for the decorator `pass_config`.

        Args:
            module_name (str): The name of the module that the config belongs to.
            lock (bool): Whether to lock the config or not.

        Returns:
            A dictionary mapping keys to corresponding values of the module config. Each entry is represented by a
            key-value pair of the dictionary. For example:

            ```
            {&#34;DEBUG&#34;: ..., &#34;INSTALLED_MODULES&#34;: [...]}
            ```

            The keys are always strings, and the values can be of any JSON-serializable type.

        Raises:
            RuntimeError: The module config is locked by another call.
        &#34;&#34;&#34;
        lock_name = f&#34;{module_name}_lock&#34;
        if getattr(self, lock_name, False):
            raise RuntimeError(f&#34;&#39;{module_name}&#39; config is locked, read access is not allowed!&#34;)
        if lock:
            # Lock module config
            setattr(self, lock_name, True)
        if module_name not in self._Modules.keys():
            # Make placeholder
            self._Modules[module_name] = dict()
        return copy.deepcopy(self._Modules[module_name])

    def set_module_config(self, module_name: str, config: dict[str, ...]) -&gt; None:
        &#34;&#34;&#34;Sets the module configuration.

        This function is intended for internal use only, used for the decorator `pass_config`.

        Args:
            module_name (str): The name of the module that the config belongs to.
            config (dict[str, ...]): A dictionary with string keys of the core configuration.

        Returns:
            None

        Raises:
            RuntimeError: The last retrieval of the module config was not locked, hence it is read-only.
        &#34;&#34;&#34;
        # Release lock module config
        lock_name = f&#34;{module_name}_lock&#34;
        is_locked = not getattr(self, lock_name, False)
        is_set = module_name in config.keys()
        if is_locked and not is_set:
            raise RuntimeError(f&#34;&#39;{module_name}&#39; config is unlocked, write access is not allowed!&#34;)
        setattr(self, lock_name, False)
        self._Modules[module_name] = copy.deepcopy(config)
        return

    def apply_module_patch(self, module_name: str, config: dict[str, ...]) -&gt; None:
        &#34;&#34;&#34;Applies a new patch to the module configuration.

        Args:
            module_name (str): The name of the module to apply patch to.
            config (dict[str, ...]): The patch of the configuration.

        Returns:
            None
        &#34;&#34;&#34;
        # Secure module config
        module_config = self.get_module_config(module_name)
        # Apply patch
        config = copy.deepcopy(config)
        config.update(module_config)
        # Release module config
        self.set_module_config(module_name, config)

    def __dict__(self) -&gt; dict[str, dict[str, ...]]:
        return {
            &#34;Core&#34;: self._Core,
            &#34;Modules&#34;: self._Modules,
        }

    @staticmethod
    def from_dict(config: dict[str]) -&gt; Config:
        if &#34;Core&#34; in config.keys() and &#34;Modules&#34; in config.keys():
            return Config(core=config[&#34;Core&#34;], modules=config[&#34;Modules&#34;])</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="SuperHelper.Core.Config.config_class.Config.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>config: dict[str]) ‑> <a title="SuperHelper.Core.Config.config_class.Config" href="#SuperHelper.Core.Config.config_class.Config">Config</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(config: dict[str]) -&gt; Config:
    if &#34;Core&#34; in config.keys() and &#34;Modules&#34; in config.keys():
        return Config(core=config[&#34;Core&#34;], modules=config[&#34;Modules&#34;])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="SuperHelper.Core.Config.config_class.Config.apply_core_patch"><code class="name flex">
<span>def <span class="ident">apply_core_patch</span></span>(<span>self, config: dict[str, ...]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Applies a new patch to core configuration.</p>
<p>This function should only be used by Core CLI.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict[str, &hellip;]</code></dt>
<dd>The patch of the configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>An error has occurred in <code>self.get_core_config()</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_core_patch(self, config: dict[str, ...]) -&gt; None:
    &#34;&#34;&#34;Applies a new patch to core configuration.

    This function should only be used by Core CLI.

    Args:
        config (dict[str, ...]): The patch of the configuration.

    Returns:
        None

    Raises:
        RuntimeError: An error has occurred in `self.get_core_config()`
    &#34;&#34;&#34;
    # Secure core config
    core_config = self.get_core_config()
    # Apply patch
    config = copy.deepcopy(config)
    config.update(core_config)
    # Release core config
    self.set_core_config(core_config)</code></pre>
</details>
</dd>
<dt id="SuperHelper.Core.Config.config_class.Config.apply_module_patch"><code class="name flex">
<span>def <span class="ident">apply_module_patch</span></span>(<span>self, module_name: str, config: dict[str, ...]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Applies a new patch to the module configuration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>module_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the module to apply patch to.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>dict[str, &hellip;]</code></dt>
<dd>The patch of the configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_module_patch(self, module_name: str, config: dict[str, ...]) -&gt; None:
    &#34;&#34;&#34;Applies a new patch to the module configuration.

    Args:
        module_name (str): The name of the module to apply patch to.
        config (dict[str, ...]): The patch of the configuration.

    Returns:
        None
    &#34;&#34;&#34;
    # Secure module config
    module_config = self.get_module_config(module_name)
    # Apply patch
    config = copy.deepcopy(config)
    config.update(module_config)
    # Release module config
    self.set_module_config(module_name, config)</code></pre>
</details>
</dd>
<dt id="SuperHelper.Core.Config.config_class.Config.get_core_config"><code class="name flex">
<span>def <span class="ident">get_core_config</span></span>(<span>self, lock: bool = True) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the configuration of Core CLI.</p>
<p>This function is intended for internal use only, used for the decorator <code><a title="SuperHelper.Core.Config.config_class.pass_config" href="#SuperHelper.Core.Config.config_class.pass_config">pass_config()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lock</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to lock the config or not.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary mapping keys to corresponding values of the core config. Each entry is represented by a
key-value pair of the dictionary. For example:</p>
<pre><code>{&quot;DEBUG&quot;: ..., &quot;INSTALLED_MODULES&quot;: [...]}
</code></pre>
<p>The keys are always strings, and the values can be of any JSON-serializable type.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>The core config is locked by another call.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_core_config(self, lock: bool = True) -&gt; dict[str, ...]:
    &#34;&#34;&#34;Gets the configuration of Core CLI.

    This function is intended for internal use only, used for the decorator `pass_config`.

    Args:
        lock (bool): Whether to lock the config or not.

    Returns:
        A dictionary mapping keys to corresponding values of the core config. Each entry is represented by a
        key-value pair of the dictionary. For example:

        ```
        {&#34;DEBUG&#34;: ..., &#34;INSTALLED_MODULES&#34;: [...]}
        ```

        The keys are always strings, and the values can be of any JSON-serializable type.

    Raises:
        RuntimeError: The core config is locked by another call.
    &#34;&#34;&#34;
    TypeCheck.ensure_bool(lock, &#34;lock&#34;)
    if Config._core_lock:
        raise RuntimeError(&#34;Core config is locked, read access is not allowed!&#34;)
    if lock:
        # Lock core config
        Config._core_lock = True
    return copy.deepcopy(self._Core)</code></pre>
</details>
</dd>
<dt id="SuperHelper.Core.Config.config_class.Config.get_module_config"><code class="name flex">
<span>def <span class="ident">get_module_config</span></span>(<span>self, module_name: str, lock: bool = True) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the configuration of the specified module.</p>
<p>This function is intended for internal use only, used for the decorator <code><a title="SuperHelper.Core.Config.config_class.pass_config" href="#SuperHelper.Core.Config.config_class.pass_config">pass_config()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>module_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the module that the config belongs to.</dd>
<dt><strong><code>lock</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to lock the config or not.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary mapping keys to corresponding values of the module config. Each entry is represented by a
key-value pair of the dictionary. For example:</p>
<pre><code>{&quot;DEBUG&quot;: ..., &quot;INSTALLED_MODULES&quot;: [...]}
</code></pre>
<p>The keys are always strings, and the values can be of any JSON-serializable type.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>The module config is locked by another call.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_module_config(self, module_name: str, lock: bool = True) -&gt; dict[str, ...]:
    &#34;&#34;&#34;Gets the configuration of the specified module.

    This function is intended for internal use only, used for the decorator `pass_config`.

    Args:
        module_name (str): The name of the module that the config belongs to.
        lock (bool): Whether to lock the config or not.

    Returns:
        A dictionary mapping keys to corresponding values of the module config. Each entry is represented by a
        key-value pair of the dictionary. For example:

        ```
        {&#34;DEBUG&#34;: ..., &#34;INSTALLED_MODULES&#34;: [...]}
        ```

        The keys are always strings, and the values can be of any JSON-serializable type.

    Raises:
        RuntimeError: The module config is locked by another call.
    &#34;&#34;&#34;
    lock_name = f&#34;{module_name}_lock&#34;
    if getattr(self, lock_name, False):
        raise RuntimeError(f&#34;&#39;{module_name}&#39; config is locked, read access is not allowed!&#34;)
    if lock:
        # Lock module config
        setattr(self, lock_name, True)
    if module_name not in self._Modules.keys():
        # Make placeholder
        self._Modules[module_name] = dict()
    return copy.deepcopy(self._Modules[module_name])</code></pre>
</details>
</dd>
<dt id="SuperHelper.Core.Config.config_class.Config.set_core_config"><code class="name flex">
<span>def <span class="ident">set_core_config</span></span>(<span>self, config: dict[str, ...]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the configuration of Core CLI.</p>
<p>This function is intended for internal use only, used for the decorator <code><a title="SuperHelper.Core.Config.config_class.pass_config" href="#SuperHelper.Core.Config.config_class.pass_config">pass_config()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict[str, &hellip;]</code></dt>
<dd>A dictionary with string keys of the core configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>The last retrieval of the core config was not locked, hence it is read-only.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_core_config(self, config: dict[str, ...]) -&gt; None:
    &#34;&#34;&#34;Sets the configuration of Core CLI.

    This function is intended for internal use only, used for the decorator `pass_config`.

    Args:
        config (dict[str, ...]): A dictionary with string keys of the core configuration.

    Returns:
        None

    Raises:
        RuntimeError: The last retrieval of the core config was not locked, hence it is read-only.
    &#34;&#34;&#34;
    # Release lock core config
    if not Config._core_lock:
        raise RuntimeError(&#34;Core config is unlocked, write access is not allowed!&#34;)
    Config._core_lock = False
    self._Core = copy.deepcopy(config)
    return</code></pre>
</details>
</dd>
<dt id="SuperHelper.Core.Config.config_class.Config.set_module_config"><code class="name flex">
<span>def <span class="ident">set_module_config</span></span>(<span>self, module_name: str, config: dict[str, ...]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the module configuration.</p>
<p>This function is intended for internal use only, used for the decorator <code><a title="SuperHelper.Core.Config.config_class.pass_config" href="#SuperHelper.Core.Config.config_class.pass_config">pass_config()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>module_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the module that the config belongs to.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>dict[str, &hellip;]</code></dt>
<dd>A dictionary with string keys of the core configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>The last retrieval of the module config was not locked, hence it is read-only.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_module_config(self, module_name: str, config: dict[str, ...]) -&gt; None:
    &#34;&#34;&#34;Sets the module configuration.

    This function is intended for internal use only, used for the decorator `pass_config`.

    Args:
        module_name (str): The name of the module that the config belongs to.
        config (dict[str, ...]): A dictionary with string keys of the core configuration.

    Returns:
        None

    Raises:
        RuntimeError: The last retrieval of the module config was not locked, hence it is read-only.
    &#34;&#34;&#34;
    # Release lock module config
    lock_name = f&#34;{module_name}_lock&#34;
    is_locked = not getattr(self, lock_name, False)
    is_set = module_name in config.keys()
    if is_locked and not is_set:
        raise RuntimeError(f&#34;&#39;{module_name}&#39; config is unlocked, write access is not allowed!&#34;)
    setattr(self, lock_name, False)
    self._Modules[module_name] = copy.deepcopy(config)
    return</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="SuperHelper.Core.Config" href="index.html">SuperHelper.Core.Config</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="SuperHelper.Core.Config.config_class.make_config_global" href="#SuperHelper.Core.Config.config_class.make_config_global">make_config_global</a></code></li>
<li><code><a title="SuperHelper.Core.Config.config_class.pass_config" href="#SuperHelper.Core.Config.config_class.pass_config">pass_config</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="SuperHelper.Core.Config.config_class.Config" href="#SuperHelper.Core.Config.config_class.Config">Config</a></code></h4>
<ul class="two-column">
<li><code><a title="SuperHelper.Core.Config.config_class.Config.apply_core_patch" href="#SuperHelper.Core.Config.config_class.Config.apply_core_patch">apply_core_patch</a></code></li>
<li><code><a title="SuperHelper.Core.Config.config_class.Config.apply_module_patch" href="#SuperHelper.Core.Config.config_class.Config.apply_module_patch">apply_module_patch</a></code></li>
<li><code><a title="SuperHelper.Core.Config.config_class.Config.from_dict" href="#SuperHelper.Core.Config.config_class.Config.from_dict">from_dict</a></code></li>
<li><code><a title="SuperHelper.Core.Config.config_class.Config.get_core_config" href="#SuperHelper.Core.Config.config_class.Config.get_core_config">get_core_config</a></code></li>
<li><code><a title="SuperHelper.Core.Config.config_class.Config.get_module_config" href="#SuperHelper.Core.Config.config_class.Config.get_module_config">get_module_config</a></code></li>
<li><code><a title="SuperHelper.Core.Config.config_class.Config.set_core_config" href="#SuperHelper.Core.Config.config_class.Config.set_core_config">set_core_config</a></code></li>
<li><code><a title="SuperHelper.Core.Config.config_class.Config.set_module_config" href="#SuperHelper.Core.Config.config_class.Config.set_module_config">set_module_config</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>